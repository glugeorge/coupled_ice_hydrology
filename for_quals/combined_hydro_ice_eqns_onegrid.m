function F = combined_hydro_ice_eqns_onegrid(QNShuxg,params)
    % unpack variables
    M = params.M;
    Q_in = params.Q_in;
    Nx = params.Nx;
    Q = QNShuxg(1:Nx);
    N = QNShuxg(Nx+1:2*Nx);
    S = QNShuxg(2*Nx+1:3*Nx);
    h = QNShuxg(3*Nx+1:4*Nx);
    u = QNShuxg(4*Nx+1:5*Nx);
    xg = QNShuxg(5*Nx+1);
    hf = (-bed(xg.*params.x0,params)/params.h0)/(params.r);

    %grid params unpack
    dt = params.dt/params.t0;
    dth= params.dt/params.th0;
    ds = params.dsigma;
    Nx = params.Nx;
    N1 = params.N1;
    sigma = params.sigma;
    sigma_elem = params.sigma_elem;
    b = -bed(xg.*sigma_elem.*params.x0,params)/params.h0; % since in velocity eqn it needs to align with h
    Fh = zeros(Nx,1);
    Fu = zeros(Nx,1);
    
    %physical params unpack
    m     = 1/params.n;
    nglen = params.n;
    accum = params.accum;
    a = accum/params.a0;
    gamma = params.gamma;
    alpha = params.alpha;
    ss = params.transient;
       
    %previous time step unpack
    h_old = params.h_old;
    xg_old = params.xg_old;
    
    % Assign values based off coupling parameters

    % Q
    fq(1) = Q(1)-Q_in; % Boundary condition

    fq(2:Nx-1) = (params.eps_r*(params.r-1))*abs(Q(2:Nx-1)).^3./S(2:Nx-1).^(8/3) +...
                        params.eps_r.*S(2:Nx-1).*N(2:Nx-1).^3 + M + ...
                        params.eps_r.*params.beta.*u(2:Nx-1).*(S(3:Nx)-S(1:Nx-2))./(2*xg*ds(2:Nx-1)) - ...
                        (Q(3:Nx)-Q(1:Nx-2))./(2*xg*ds(2:Nx-1));
    fq(N1) = (Q(N1+1)-Q(N1))/ds(N1) - (Q(N1)-Q(N1-1))/ds(N1-1);
    fq(Nx) = (params.eps_r*(params.r-1))*abs(Q(Nx)).^3./S(Nx).^(8/3) +...
                        params.eps_r*S(Nx).*N(Nx).^3 + M + ...
                        params.eps_r.*params.beta.*u(Nx).*(S(Nx)-S(Nx-1))./(xg*ds(Nx-1)) - ...
                        (Q(Nx)-Q(Nx-1))./(xg*ds(Nx-1)); % one sided difference 
    % N 
    % psi = -params.rho_w*params.g.*dbdx-params.rho_i*params.g*dhdx
    fn(1) = Q(1).*abs(Q(1))./(S(1).^(8/3)) - ((b(2)-b(1))./(ds(1)*xg) - params.r.*(h(2)-h(1))./(ds(1)*xg)) - ...
                        params.delta*(N(2)-N(1))./(xg*ds(1)); % use 1 sided difference instead of symmetry argument
    fn(2:Nx-1) =  Q(2:Nx-1).*abs(Q(2:Nx-1))./(S(2:Nx-1).^(8/3)) - ((b(3:Nx)-b(2:Nx-1))./(ds(2:Nx-1)*xg) - params.r.*(h(3:Nx)-h(2:Nx-1))./(ds(2:Nx-1)*xg)) - ...
                        params.delta*(N(3:Nx)-N(1:Nx-2))./(2*xg*ds(2:Nx-1));
    fn(N1) = (N(N1+1)-N(N1))/ds(N1) - (N(N1)-N(N1-1))/ds(N1-1);
    fn(Nx) = N(Nx) - params.N_terminus; % Boundary condition
    % S
    fs(1) = abs(Q(1)).^3./(S(1).^(8/3)) - ... 
                        S(1).*N(1).^3 + ...
                        (ss.*sigma(1).*(xg-xg_old)./dth - params.beta.*u(1)).*(S(2)-S(1))./(xg*ds(1)) - ...
                        ss.*(S(1)-params.S_old(1))./dth;
    fs(2:Nx-1)= abs(Q(2:Nx-1)).^3./(S(2:Nx-1).^(8/3)) - ... 
                        S(2:Nx-1).*N(2:Nx-1).^3 + ...
                        (ss.*sigma(2:Nx-1).*(xg-xg_old)./dth - params.beta.*u(2:Nx-1)).*(S(3:Nx)-S(1:Nx-2))./(2*xg*ds(2:Nx-1)) - ...
                        ss.*(S(2:Nx-1)- params.S_old(2:Nx-1))./dth; 
    fs(N1) = (S(N1+1)-S(N1))/ds(N1) - (S(N1)-S(N1-1))/ds(N1-1);
    fs(Nx)= abs(Q(Nx)).^3./(S(Nx).^(8/3)) - ... 
                        S(Nx).*N(Nx).^3 + ...
                        (ss.*sigma(Nx).*(xg-xg_old)./dth - params.beta.*u(Nx)).*(S(Nx)-S(Nx-1))./(xg*ds(Nx-1)) - ...
                        ss.*(S(Nx)-params.S_old(Nx))./dth; % one sided difference

    % ice sheet equations
    Fh(1)      = ss.*(h(1)-h_old(1))./dt + (2.*h(1).*u(1))./(ds(1).*xg) - a;
    Fh(2)      = ss.*(h(2)-h_old(2))./dt -...
                    ss.*sigma_elem(2).*(xg-xg_old).*(h(3)-h(1))./(2*dt.*ds(2).*xg) +...
                        (h(2).*(u(2)+u(1)))./(2*xg.*ds(2)) -...
                            a;
    Fh(3:Nx-1) = ss.*(h(3:Nx-1)-h_old(3:Nx-1))./dt -...
                    ss.*sigma_elem(3:Nx-1).*(xg-xg_old).*(h(4:Nx)-h(2:Nx-2))./(2*dt.*ds(3:Nx-1).*xg) +...
                        (h(3:Nx-1).*(u(3:Nx-1)+u(2:Nx-2)) - h(2:Nx-2).*(u(2:Nx-2)+u(1:Nx-3)))./(2*xg.*ds(3:Nx-1)) -...
                            a;
    
    Fh(N1) = (1+0.5*(1+(ds(N1)/ds(N1-1))))*h(N1) - 0.5*(1+(ds(N1)/ds(N1-1)))*h(N1-1) - h(N1+1);
                        
    Fh(Nx)     = ss.*(h(Nx)-h_old(Nx))./dt -...
                    ss.*sigma_elem(Nx).*(xg-xg_old).*(h(Nx)-h(Nx-1))./(dt.*ds(Nx-1).*xg) +...
                        (h(Nx).*(u(Nx)+u(Nx-1)) - h(Nx-1).*(u(Nx-1)+u(Nx-2)))./(2*xg.*ds(Nx-1)) -...
                            a;

	%velocity
    Fu(1)      = (alpha).*(1./(xg.*ds(1)).^((1/nglen)+1)).*...
                 (h(2).*(u(2)-u(1)).*abs(u(2)-u(1)).^((1/nglen)-1) -...
                  h(1).*(2*u(1)).*abs(2*u(1)).^((1/nglen)-1)) -...
                  gamma.*N(1).* (u(1)./(u(1) + N(1).^nglen)).^m -...
                  0.5.*(h(1)+h(2)).*(h(2)-b(2)-h(1)+b(1))./(xg.*ds(1));
    Fu(2:Nx-1) = (alpha).*(1./(xg.*ds(2:Nx-1)).^((1/nglen)+1)).*...
                 (h(3:Nx).*(u(3:Nx)-u(2:Nx-1)).*abs(u(3:Nx)-u(2:Nx-1)).^((1/nglen)-1) -...
                  h(2:Nx-1).*(u(2:Nx-1)-u(1:Nx-2)).*abs(u(2:Nx-1)-u(1:Nx-2)).^((1/nglen)-1)) -...
                  gamma.*N(2:Nx-1).*(u(2:Nx-1)./(u(2:Nx-1) + N(2:Nx-1).^nglen)).^m -...
                  0.5.*(h(2:Nx-1)+h(3:Nx)).*(h(3:Nx)-b(3:Nx)-h(2:Nx-1)+b(2:Nx-1))./(xg.*ds(2:Nx-1));
    Fu(N1)     = (u(N1+1)-u(N1))/ds(N1) - (u(N1)-u(N1-1))/ds(N1-1);
    Fu(Nx)     = alpha.*(1./(xg.*ds(Nx-1)).^(1/nglen)).*...
                 (abs(u(Nx)-u(Nx-1)).^((1/nglen)-1)).*(u(Nx)-u(Nx-1)) - 0.5*(1-params.r)*hf;
             
    Fxg        = 3*h(Nx) - h(Nx-1) - 2*hf; 

    F = [fq';fn';fs';Fh;Fu;Fxg];


    %% Deprecated
%     fq(1) = (params.eps_r*(params.r-1))*abs(Q(1)).^3./S(1).^(8/3) +...
%                         params.eps_r*S(1).*N(1).^3 + M + ...
%                         (Q(1)-Q_in)./(0.5*xg*ds(1)); % Boundary condition
% 
%     fq(2:Nx-1) = (params.eps_r*(params.r-1))*abs(Q(2:Nx-1)).^3./S(2:Nx-1).^(8/3) +...
%                         params.eps_r.*S(2:Nx-1).*N(2:Nx-1).^3 + M + ...
%                         params.eps_r.*params.beta.*u(2:Nx-1).*(S(3:Nx)-S(1:Nx-2))./(2*xg*ds(2:Nx-1)) - ...
%                         (Q(3:Nx)-Q(1:Nx-2))./(2*xg*ds(2:Nx-1));
%     fq(N1) = (Q(N1+1)-Q(N1))/ds(N1) - (Q(N1)-Q(N1-1))/ds(N1-1);
%     fq(Nx) = (params.eps_r*(params.r-1))*abs(Q(Nx)).^3./S(Nx).^(8/3) +...
%                         params.eps_r*S(Nx).*N(Nx).^3 + M + ...
%                         params.eps_r.*params.beta.*u(Nx).*(S(Nx)-S(Nx-1))./(xg*ds(Nx-1)) - ...
%                         (Q(Nx)-Q(Nx-1))./(xg*ds(Nx-1)); % one sided difference 
%     % N 
%     % psi = -params.rho_w*params.g.*dbdx-params.rho_i*params.g*dhdx
%     fn(1) = Q(1).*abs(Q(1))./(S(1).^(8/3)) - ((b(2)-b(1))./(ds(1)*xg) - params.r.*(h(2)-h(1))./(ds(1)*xg)) - ...
%                         params.delta*(N(2)-N(1))./(xg*ds(1)); % use 1 sided difference instead of symmetry argument
%     fn(2:Nx-1) =  Q(2:Nx-1).*abs(Q(2:Nx-1))./(S(2:Nx-1).^(8/3)) - ((b(3:Nx)-b(2:Nx-1))./(ds(2:Nx-1)*xg) - params.r.*(h(3:Nx)-h(2:Nx-1))./(ds(2:Nx-1)*xg)) - ...
%                         params.delta*(N(3:Nx)-N(1:Nx-2))./(2*xg*ds(2:Nx-1));
%     fn(N1) = (N(N1+1)-N(N1))/ds(N1) - (N(N1)-N(N1-1))/ds(N1-1);
%     fn(Nx) = N(Nx) - params.N_terminus; % Boundary condition
%     % S
%     fs(1) = abs(Q(1)).^3./(S(1).^(8/3)) - ... 
%                         S(1).*N(1).^3 + ...
%                         ss.*(S(1)-params.S_old(1))./dth;
%     fs(2:Nx-1)= abs(Q(2:Nx-1)).^3./(S(2:Nx-1).^(8/3)) - ... 
%                         S(2:Nx-1).*N(2:Nx-1).^3 + ...
%                         (ss.*sigma(2:Nx-1).*(xg-xg_old)./dth - params.beta.*u(2:Nx-1)).*(S(3:Nx)-S(1:Nx-2))./(2*xg*ds(2:Nx-1)) - ...
%                         ss.*(S(2:Nx-1)- params.S_old(2:Nx-1))./dth; 
%     fs(N1) = (S(N1+1)-S(N1))/ds(N1) - (S(N1)-S(N1-1))/ds(N1-1);
%     fs(Nx)= abs(Q(Nx)).^3./(S(Nx).^(8/3)) - ... 
%                         S(Nx).*N(Nx).^3 + ...
%                         (ss.*sigma(Nx).*(xg-xg_old)./dth - params.beta.*u(Nx)).*(S(Nx)-S(Nx-1))./(xg*ds(Nx-1)) - ...
%                         ss.*(S(Nx)-params.S_old(Nx))./dth; % one sided difference
